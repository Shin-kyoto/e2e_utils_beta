From 34e144cb813659c1395a33ab458bac0c8d5f9ecd Mon Sep 17 00:00:00 2001
From: Shin-kyoto <aquashin0202@gmail.com>
Date: Wed, 6 Aug 2025 10:48:43 +0900
Subject: [PATCH] feat(autoware_tensorrt_vad): add publisher for base_link
 trajectory

Signed-off-by: Shin-kyoto <aquashin0202@gmail.com>
---
 .../config/ml_package_vad_tiny.param.yaml     |   8 +-
 .../config/vad_tiny.param.yaml                |   2 +-
 .../autoware/tensorrt_vad/vad_interface.hpp   |  16 +++
 .../autoware/tensorrt_vad/vad_node.hpp        |   2 +
 .../launch/vad.launch.xml                     |   6 +-
 .../lib/vad_interface.cpp                     | 130 ++++++++++++++++++
 .../autoware_tensorrt_vad/src/vad_node.cpp    |  10 ++
 7 files changed, 168 insertions(+), 6 deletions(-)

diff --git a/planning/autoware_tensorrt_vad/config/ml_package_vad_tiny.param.yaml b/planning/autoware_tensorrt_vad/config/ml_package_vad_tiny.param.yaml
index 9c8a6882ed..440a702e52 100644
--- a/planning/autoware_tensorrt_vad/config/ml_package_vad_tiny.param.yaml
+++ b/planning/autoware_tensorrt_vad/config/ml_package_vad_tiny.param.yaml
@@ -4,11 +4,11 @@
       num_cameras: 6
     interface_params:
       # # awsim
-      # input_image_width: 1920
-      # input_image_height: 1080
+      input_image_width: 1920
+      input_image_height: 1080
       # # autoware xx1
-      input_image_width: 1466
-      input_image_height: 1122
+      # input_image_width: 1466
+      # input_image_height: 1122
       # nuScenes
       # input_image_width: 1653
       # input_image_height: 940
diff --git a/planning/autoware_tensorrt_vad/config/vad_tiny.param.yaml b/planning/autoware_tensorrt_vad/config/vad_tiny.param.yaml
index 7229b00ca5..4b097ee442 100644
--- a/planning/autoware_tensorrt_vad/config/vad_tiny.param.yaml
+++ b/planning/autoware_tensorrt_vad/config/vad_tiny.param.yaml
@@ -1,7 +1,7 @@
 /**:
   ros__parameters:
     node_params:
-      use_raw: [false, false, false, false, false, false] # per camera: if true, use raw image data, otherwise use compressed images
+      use_raw: [true, false, false, false, false, false] # per camera: if true, use raw image data, otherwise use compressed images
     interface_params:
       map_colors: [0.3922, 0.5843, 0.9294,  # divider: cornflowerblue
                    1.0, 0.0, 0.0,           # ped_crossing: red  
diff --git a/planning/autoware_tensorrt_vad/include/autoware/tensorrt_vad/vad_interface.hpp b/planning/autoware_tensorrt_vad/include/autoware/tensorrt_vad/vad_interface.hpp
index 56cf3bbc08..0b300b98e0 100644
--- a/planning/autoware_tensorrt_vad/include/autoware/tensorrt_vad/vad_interface.hpp
+++ b/planning/autoware_tensorrt_vad/include/autoware/tensorrt_vad/vad_interface.hpp
@@ -110,7 +110,9 @@ private:
 struct VadOutputTopicData
 {
   autoware_internal_planning_msgs::msg::CandidateTrajectories candidate_trajectories;
+  autoware_internal_planning_msgs::msg::CandidateTrajectories candidate_trajectories_base;
   autoware_planning_msgs::msg::Trajectory trajectory;
+  autoware_planning_msgs::msg::Trajectory trajectory_base;
   visualization_msgs::msg::MarkerArray map_points;  // Transformed map points in Autoware coordinate system
   autoware_perception_msgs::msg::PredictedObjects objects;
 };
@@ -144,6 +146,11 @@ public:
     const rclcpp::Time & stamp,
     double trajectory_timestep,
     const Eigen::Matrix4f & base2map_transform) const;
+
+  autoware_internal_planning_msgs::msg::CandidateTrajectories process_candidate_trajectories_base(
+    const std::map<int32_t, std::vector<float>> & predicted_trajectories,
+    const rclcpp::Time & stamp,
+    double trajectory_timestep) const;
   
   autoware_planning_msgs::msg::Trajectory process_trajectory(
     const std::vector<float> & predicted_trajectory,
@@ -151,6 +158,11 @@ public:
     double trajectory_timestep,
     const Eigen::Matrix4f & base2map_transform) const;
 
+  autoware_planning_msgs::msg::Trajectory process_trajectory_base(
+    const std::vector<float> & predicted_trajectory,
+    const rclcpp::Time & stamp,
+    double trajectory_timestep) const;
+
   // Convert map_points from VAD coordinate system to Autoware coordinate system
   visualization_msgs::msg::MarkerArray process_map_points(
     const std::vector<MapPolyline> & vad_map_polylines,
@@ -231,6 +243,10 @@ private:
     const std::vector<float> & predicted_trajectory,
     double trajectory_timestep,
     const Eigen::Matrix4f & base2map_transform) const;
+
+  std::vector<autoware_planning_msgs::msg::TrajectoryPoint> create_trajectory_points_base(
+    const std::vector<float> & predicted_trajectory,
+    double trajectory_timestep) const;
 };
 
 }  // namespace autoware::tensorrt_vad
diff --git a/planning/autoware_tensorrt_vad/include/autoware/tensorrt_vad/vad_node.hpp b/planning/autoware_tensorrt_vad/include/autoware/tensorrt_vad/vad_node.hpp
index ab7b85f6c9..8eafb09168 100644
--- a/planning/autoware_tensorrt_vad/include/autoware/tensorrt_vad/vad_node.hpp
+++ b/planning/autoware_tensorrt_vad/include/autoware/tensorrt_vad/vad_node.hpp
@@ -115,7 +115,9 @@ private:
 
   // Publishers
   rclcpp::Publisher<autoware_planning_msgs::msg::Trajectory>::SharedPtr trajectory_publisher_;
+  rclcpp::Publisher<autoware_planning_msgs::msg::Trajectory>::SharedPtr trajectory_base_publisher_;
   rclcpp::Publisher<autoware_internal_planning_msgs::msg::CandidateTrajectories>::SharedPtr candidate_trajectories_publisher_;
+  rclcpp::Publisher<autoware_internal_planning_msgs::msg::CandidateTrajectories>::SharedPtr candidate_trajectories_base_publisher_;
   rclcpp::Publisher<autoware_perception_msgs::msg::PredictedObjects>::SharedPtr predicted_objects_publisher_;
   rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr map_points_publisher_;
 
diff --git a/planning/autoware_tensorrt_vad/launch/vad.launch.xml b/planning/autoware_tensorrt_vad/launch/vad.launch.xml
index 7d23600337..a043595cc0 100644
--- a/planning/autoware_tensorrt_vad/launch/vad.launch.xml
+++ b/planning/autoware_tensorrt_vad/launch/vad.launch.xml
@@ -14,7 +14,7 @@
   <arg name="camera_info4" default="/sensing/camera/camera4/camera_info"/>
   <arg name="camera_info5" default="/sensing/camera/camera5/camera_info"/>
 
-  <arg name="image0" default="/sensing/camera/camera0/image_rect_color"/>
+  <arg name="image0" default="/sensing/camera/image_raw"/>
   <arg name="image1" default="/sensing/camera/camera1/image_rect_color"/>
   <arg name="image2" default="/sensing/camera/camera2/image_rect_color"/>
   <arg name="image3" default="/sensing/camera/camera3/image_rect_color"/>
@@ -27,6 +27,8 @@
   <arg name="output/objects" default="perception/object_recognition/vad/objects"/>
   <arg name="output/trajectory" default="planning/vad/trajectory"/>
   <arg name="output/trajectories" default="planning/vad/trajectories"/>
+  <arg name="output/trajectory_base" default="planning/vad/trajectory_base"/>
+  <arg name="output/trajectories_base" default="planning/vad/trajectories_base"/>
   <arg name="output/map" default="debug/vad/map"/>
 
   <node pkg="autoware_tensorrt_vad" exec="vad_node" name="vad" output="screen" args="--ros-args --log-level $(var log_level)">
@@ -36,6 +38,8 @@
     <remap from="~/output/objects" to="$(var output/objects)"/>
     <remap from="~/output/trajectory" to="$(var output/trajectory)"/>
     <remap from="~/output/trajectories" to="$(var output/trajectories)"/>
+    <remap from="~/output/trajectory_base" to="$(var output/trajectory_base)"/>
+    <remap from="~/output/trajectories_base" to="$(var output/trajectories_base)"/>
     <remap from="~/output/map" to="$(var output/map)"/>
 
     <remap from="~/input/camera_info0" to="$(var camera_info0)"/>
diff --git a/planning/autoware_tensorrt_vad/lib/vad_interface.cpp b/planning/autoware_tensorrt_vad/lib/vad_interface.cpp
index 66555b9a8d..0772b28e9b 100644
--- a/planning/autoware_tensorrt_vad/lib/vad_interface.cpp
+++ b/planning/autoware_tensorrt_vad/lib/vad_interface.cpp
@@ -80,11 +80,17 @@ VadOutputTopicData VadInterface::convert_output(
   // Convert candidate trajectories
   output_topic_data.candidate_trajectories = process_candidate_trajectories(
     vad_output_data.predicted_trajectories_, stamp, trajectory_timestep, base2map_transform);
+
+  output_topic_data.candidate_trajectories_base = process_candidate_trajectories_base(
+    vad_output_data.predicted_trajectories_, stamp, trajectory_timestep);
   
   // Convert trajectory
   output_topic_data.trajectory = process_trajectory(
     vad_output_data.predicted_trajectory_, stamp, trajectory_timestep, base2map_transform);
 
+  output_topic_data.trajectory_base = process_trajectory_base(
+    vad_output_data.predicted_trajectory_, stamp, trajectory_timestep);
+
   // Convert map_points from VAD coordinate system to Autoware coordinate system
   output_topic_data.map_points = process_map_points(vad_output_data.map_polylines_, stamp, base2map_transform);
 
@@ -518,6 +524,130 @@ std::vector<autoware_planning_msgs::msg::TrajectoryPoint> VadInterface::create_t
   return points;
 }
 
+std::vector<autoware_planning_msgs::msg::TrajectoryPoint> VadInterface::create_trajectory_points_base(
+  const std::vector<float> & predicted_trajectory,
+  double trajectory_timestep) const
+{
+  std::vector<autoware_planning_msgs::msg::TrajectoryPoint> points;
+
+  // 0秒目の点 (0,0) を追加 - base_link座標系
+  autoware_planning_msgs::msg::TrajectoryPoint initial_point;
+  initial_point.pose.position.x = 0.0;
+  initial_point.pose.position.y = 0.0;
+  initial_point.pose.position.z = 0.0;
+  initial_point.pose.orientation = create_quaternion_from_yaw(0.0);
+  initial_point.longitudinal_velocity_mps = 2.5;
+  initial_point.lateral_velocity_mps = 0.0;
+  initial_point.acceleration_mps2 = 0.0;
+  initial_point.heading_rate_rps = 0.0;
+  initial_point.time_from_start.sec = 0;
+  initial_point.time_from_start.nanosec = 0;
+  points.push_back(initial_point);
+
+  double prev_x = 0.0;
+  double prev_y = 0.0;
+  auto prev_orientation = initial_point.pose.orientation;
+
+  for (size_t i = 0; i < predicted_trajectory.size(); i += 2) {
+    autoware_planning_msgs::msg::TrajectoryPoint point;
+
+    float vad_x = predicted_trajectory[i];
+    float vad_y = predicted_trajectory[i + 1];
+
+    // VAD座標系からAutoware base_link座標系に変換
+    auto [aw_x, aw_y, aw_z] = vad2aw_xyz(vad_x, vad_y, 0.0f);
+    // aw_y = 0.0f;
+    // printf("aw_x, aw_y: %f, %f\n", aw_x, aw_y);
+    point.pose.position.x = aw_x;
+    point.pose.position.y = aw_y;
+    point.pose.position.z = aw_z;
+
+    // 方向を計算
+    if (i + 2 < predicted_trajectory.size()) {
+      float vad_dx = predicted_trajectory[i + 2] - predicted_trajectory[i];
+      float vad_dy = predicted_trajectory[i + 3] - predicted_trajectory[i + 1];
+      auto [aw_dx, aw_dy, aw_dz] = vad2aw_xyz(vad_dx, vad_dy, 0.0f);
+
+      float yaw = std::atan2(aw_dy, aw_dx);
+      point.pose.orientation = create_quaternion_from_yaw(yaw);
+    } else {
+      point.pose.orientation = prev_orientation;
+    }
+
+    // 速度を計算（前の点との距離を時間間隔で割る）
+    auto distance = std::hypot(point.pose.position.x - prev_x, point.pose.position.y - prev_y);
+    point.longitudinal_velocity_mps = static_cast<float>(distance / trajectory_timestep);
+
+    point.lateral_velocity_mps = 0.0;
+    point.acceleration_mps2 = 0.0;
+    point.heading_rate_rps = 0.0;
+
+    // time_from_startを設定（1秒, 2秒, 3秒, 4秒, 5秒, 6秒）
+    size_t point_index = i / 2;
+    double time_sec = (point_index + 1) * trajectory_timestep;
+    point.time_from_start.sec = static_cast<int32_t>(time_sec);
+    point.time_from_start.nanosec = static_cast<uint32_t>((time_sec - point.time_from_start.sec) * 1e9);
+
+    // 次の計算のために現在の位置を保存
+    prev_x = point.pose.position.x;
+    prev_y = point.pose.position.y;
+    prev_orientation = point.pose.orientation;
+
+    points.push_back(point);
+  }
+
+  return points;
+}
+
+autoware_internal_planning_msgs::msg::CandidateTrajectories VadInterface::process_candidate_trajectories_base(
+  const std::map<int32_t, std::vector<float>> & predicted_trajectories,
+  const rclcpp::Time & stamp,
+  double trajectory_timestep) const
+{
+  // CandidateTrajectories メッセージを作成
+  autoware_internal_planning_msgs::msg::CandidateTrajectories candidate_trajectories_msg;
+
+  // 各コマンドの軌道をCandidateTrajectoryとして追加
+  for (const auto& [command_idx, trajectory] : predicted_trajectories) {
+    autoware_internal_planning_msgs::msg::CandidateTrajectory candidate_trajectory;
+
+    // ヘッダーを設定 - base_link座標系
+    candidate_trajectory.header.stamp = stamp;
+    candidate_trajectory.header.frame_id = "base_link";
+
+    // generator_idを設定（ユニークなUUID）
+    candidate_trajectory.generator_id = autoware_utils_uuid::generate_uuid();
+
+    candidate_trajectory.points = create_trajectory_points_base(trajectory, trajectory_timestep);
+
+    candidate_trajectories_msg.candidate_trajectories.push_back(candidate_trajectory);
+
+    // 各コマンドのGeneratorInfoを追加
+    autoware_internal_planning_msgs::msg::GeneratorInfo generator_info;
+    generator_info.generator_id = autoware_utils_uuid::generate_uuid();
+    generator_info.generator_name.data = "autoware_tensorrt_vad_cmd_base_" + std::to_string(command_idx);
+    candidate_trajectories_msg.generator_info.push_back(generator_info);
+  }
+
+  return candidate_trajectories_msg;
+}
+
+autoware_planning_msgs::msg::Trajectory VadInterface::process_trajectory_base(
+  const std::vector<float> & predicted_trajectory,
+  const rclcpp::Time & stamp,
+  double trajectory_timestep) const
+{
+  autoware_planning_msgs::msg::Trajectory trajectory_msg;
+
+  // ヘッダーを設定 - base_link座標系
+  trajectory_msg.header.stamp = stamp;
+  trajectory_msg.header.frame_id = "base_link";
+
+  trajectory_msg.points = create_trajectory_points_base(predicted_trajectory, trajectory_timestep);
+
+  return trajectory_msg;
+}
+
 autoware_internal_planning_msgs::msg::CandidateTrajectories VadInterface::process_candidate_trajectories(
   const std::map<int32_t, std::vector<float>> & predicted_trajectories,
   const rclcpp::Time & stamp,
diff --git a/planning/autoware_tensorrt_vad/src/vad_node.cpp b/planning/autoware_tensorrt_vad/src/vad_node.cpp
index b104746438..08c6314283 100644
--- a/planning/autoware_tensorrt_vad/src/vad_node.cpp
+++ b/planning/autoware_tensorrt_vad/src/vad_node.cpp
@@ -99,6 +99,14 @@ VadNode::VadNode(const rclcpp::NodeOptions & options)
       this->create_publisher<autoware_internal_planning_msgs::msg::CandidateTrajectories>(
           "~/output/trajectories", rclcpp::QoS(1));
 
+  trajectory_base_publisher_ =
+      this->create_publisher<autoware_planning_msgs::msg::Trajectory>(
+          "~/output/trajectory_base", rclcpp::QoS(1));
+
+  candidate_trajectories_base_publisher_ =
+      this->create_publisher<autoware_internal_planning_msgs::msg::CandidateTrajectories>(
+          "~/output/trajectories_base", rclcpp::QoS(1));
+
   predicted_objects_publisher_ =
       this->create_publisher<autoware_perception_msgs::msg::PredictedObjects>(
           "~/output/objects",
@@ -413,9 +421,11 @@ void VadNode::publish(const VadOutputTopicData & vad_output_topic_data)
 {
   // Publish selected trajectory
   trajectory_publisher_->publish(vad_output_topic_data.trajectory);
+  trajectory_base_publisher_->publish(vad_output_topic_data.trajectory_base);
 
   // Publish candidate trajectories
   candidate_trajectories_publisher_->publish(vad_output_topic_data.candidate_trajectories);
+  candidate_trajectories_base_publisher_->publish(vad_output_topic_data.candidate_trajectories_base);
 
   // // Publish predicted objects
   // predicted_objects_publisher_->publish(vad_output_topic_data.objects);
-- 
2.34.1

